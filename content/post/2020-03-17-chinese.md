---
title: "中文测试"
date: 2020-03-17T22:30:34+08:00
author: Kip
notShowHome: false

toc: true
slug: chinese test
description: 这是博客的中文字体测试

categories:
    - 例子
tags:
    - 测试
---

# C dynamic memory allocation

[wikipedia](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation)

## Introduction

C dynamic memory allocation 对应着 C 语言中的动态内存分配的手动内存管理（manual memory management）。包括库 `stdli.h` 中的 `malloc` 、`realloc`、`calloc`、`free`。

> C++ 中也包含这四个函数，但是推荐使用 `new`、`delete`。

C 语言分配内存有三种方式：① 静态；② 自动；③ 动态。

- 静态持续变量，分配在主存中，会一直伴随执行代码，持续整个生命周期。
- 自动持续变量，分配在 **栈**（`stack`）中，随函数的 `called` 和 `return` 调用而变化。
    - 静态、自动变量分配的内存大小在编译时固定（可变长度自动数组的情况除外）。
- 动态内存分配，内存被更明确（但更灵活）地管理。通过 *free store* （非正式称为 **堆**，`heap`）分配，这是一个为此目的构建的内存区域。
    - C 语言中，函数 `malloc` 被用来在 heap 上分配一块内存。返回一个空指针（`void*`）。

        Function | Description
        ---|---
        malloc | allocates the specified number of bytes
        realloc | increase or decrease the size of the specified block of memory, moving it if necessary
        calloc | allocates the specified number of bytes and initializes them to 0
        free | releases the specified block of memory back to the system

## Type Safety

- 强制类型转换的缺点

在缺少 `malloc` 原型时，C90 标准要求 C 编译器假设 `malloc` 返回一个 `int` 类型。如果没有强制类型转化（casting），C90 就会诊断分配给这个 `int` 的指针；否则，不诊断。

> On certain architectures and data models (such as LP64 on 64-bit systems, where `long` and pointers are 64-bit and `int` is 32-bit), this error can actually result in undefined behaviour, as the implicitly declared `malloc` returns a 32-bit value whereas the actually defined function returns a 64-bit value. 

有可能期望的是 32bit 的返回值，但实际返回的是 64bit。

## Common errors

- logical errors
    - 空悬指针（dangling pointer），after a call to `free`
    - 野指针（wild pointer），before a call to `malloc`
    - 重复释放（double free），calling `free` twice

## Problems

### 1. [C-Read value from a specific memory address](https://stackoverflow.com/questions/34347558/c-read-value-from-a-specific-memory-address/34347588)

> Each process has its own [virtual address space](https://en.wikipedia.org/wiki/Virtual_address_space), so, address `0x12345678` in one program will not be the same as address 0x12345678 in another.

每个进程都有其各自的虚拟地址空间，所以一个程序的地址 `0x12345678` 和另一个程序的地址 `0x12345678` 是不一样的。

```c
#include <stdio.h>

int main(int argc, char *argv[]){
    char *ptr = (char *)0x12345678; //the addr you wish to access the contents of
    printf("%c\n", *ptr); 
    /*
    this will give you the first byte, you can add any more bytes you need to the ptr itself, like so: *(ptr + nbyte).
    */
    return 0;
}
```

比如，上面的程序只会得到 `Segmentation fault (core dumped)`。

> This does answer your question in the OP, though. [Here is Another Virtual Memory learning resource](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf).

### 2. [OSTEP/vm-intro.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf) 阅读笔记

#### （1）The Address Space

##### Introduction

进程的地址空间包含正在运行的程序的所有内存状态。

- The `code` of program (instructions) 驻留在内存某处，即在地址空间中
- 使用 `stack` 追踪函数调用链（the function call chain）中的正在运行的程序。并，
    - allocate local varibles 
    - pass parameters 
    - return values to and from routines
- 使用 `heap` 作：
    - dynamically-allocated
    - user-management memory
    - 例如，receive from a call to `malloc()` int C or `new` in an object-oriented language。
    ![test](/img/test.png)

In Figure 13.3，Code is static（thus easy to place in memory），so we can place it at the top of the address space and know that it won't need any more space as the program runs。

剩下的 `heap` 和 `stack` 都会随着程序的运行而占用更多的地址空间。

> - the `heap` thus starts just after the code (at 1KB) and grows downward (say when a user requests more memory via `malloc()`);   
> - the `stack` starts at 16KB and grows upward (say when a user makes a procedure call).

这中放置方式只是一种俗成（convention）。

> as we’ll see later, when multiple `threads` co-exist in an address space, no
nice way to divide the address space like this works anymore, alas.

##### The Crux（症结）

> **THE CRUX: HOW TO VIRTUALIZE MEMORY**  
> How can the OS build this abstraction of a private, potentially large address space for multiple running processes (all sharing memory) on top of a single, physical memory?

运行中的程序自认为它加载到内存中是 ++从地址 0 开始++ 的，并且有很大的剩余空间（32bit or 64bit）。

> Some modern OS’s take isolation even further, by ++walling off pieces of the OS from other pieces of the OS++. Such microkernels thus may provide greater reliability than typical monolithic kernel designs.

#### （2）The Goals of a virtual memory(VM)

- 1、Transparency（透明性）
- 2、Efficiency（效率），（Time & Space）运行不要太慢，占用空间不要增加太多。这样就需要依赖硬件支持。
- 3、Protection（保护），即 Isolation。

##### Aside：Every address you see is virtual

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    printf("location of code : %p\n", (void *) main);
    printf("location of heap : %p\n", (void *) malloc(1));
    
    int x = 3;
    printf("location of stack : %p\n", (void *) &x);
    return x;
}
```

```
// a 64-bit OS output:
location of code : 0x7f4d73c006fa
location of heap : 0x7fffe64e9270
location of stack : 0x7fffeea424b4
```

这些都是 **虚拟地址**。

